---
layout: post
title: 关于解耦的思考
categories: 解耦
tags: 解耦
 
---

## 产品线内部的解耦

### 解耦方向：

#### 插件化

**插件的好处：**

1.编译时不用-l 写死链接上这个库

2.可以通过代码决定运行时啥时候加载，而且可以卸载。

3.各插件之间可以通过函数指针的形式进一步解除依赖



不使用插件的场景：

![](/assets/images/so1.PNG)

假设依赖关系是这样的，那么编译顺序基本上得是so3->so2->so1->可执行程序。这样依赖的就比较紧密，编译顺序也比较固定。

使用插件：

![](/assets/images/so2.PNG)

对于插件来说，编译时可以不链接，在运行时才加载，所以编译的顺序无所谓。比如插件1用到了插件2中的函数，那么插件1可以动态的使用dlopen，dlsym等函数从插件2中拿到对应的函数使用。

插件的加载流程是，加载父插件，然后父插件再去加载子插件。一般来说只有插件加载的init函数是通过dlsym来获取的，其他的函数如果都用这个方式获取，就有些死板和不方便了。更加灵活的一种方式是采用**函数指针**（即注册的方式）来更灵活的解决各插件之间的依赖。

举例来说，插件1使用到了插件2中的函数，两种方式：

1.通过dlsym获取这个函数，然后使用，但是过程有些繁琐，必须先获取再使用。

2.函数指针的方式是：插件1中定义一个**全局的函数指针**，然后直接用这个函数指针来代替这个函数，即使是这个函数指针没有实际指向内容，这样编译时是没有什么问题的。什么时候给这个函数指针赋值呢？等到插件2初始化的时候。相当于是插件1给了一个函数的注册点，然后插件2等到初始化的时候再往上注册就行了。

这种方式和方式1比起来，更加灵活，插件1不用dlsym获取到了真正的函数之后才能用，直接可以先用起来，然后插件2再往上注册真正的函数就行了。

如果插件2和插件3想互相用对方的函数应该怎么办呢？

1.直接-l链接过来用，这样插件之前就有了耦合，不建议使用

2.通过dlsym获取这个函数

3.函数指针的方式：在插件2和插件3的父插件1中定义一些**全局的函数指针**，因为插件2和插件3是插件1的子插件，所以可以直接获取到这些函数指针，并直接使用。插件2在加载的时候，获取到插件1定义的函数指针，其中有些指针是指向插件2的，这时给它附上值，这个函数指针就真正的指向了一个实际的函数。如果插件2用到了一些插件3的函数，获取到指针之后也可以直接用，这时指针还未实际指向插件3的函数，但是不要紧，等到插件3初始化的时候把函数注册上去就行了。

上面说到的全局函数指针可以优化成：static定义的指针，然后插件1再提供一个函数来操作这个指针就行。























## 产品线之间的解耦
