---
layout: post
title: 编译相关知识
categories: 编译
tags: 编译 makefile
 
---

如果编译时遇到 undefine reference to symbol xxx，表示找不到这个符号，编译时-l链接上这个库就行了



ldd +编译出来的文件，就可以看该文件链接的动态库



静态目标文件.o文件，编译时就把内容加到可执行文件里



第二次编译时，如果makefile里写的依赖的文件变的话，会重新编译，否则不会重新编译。通常是不会把.h文件写到makefile的依赖里的，如果改完之后直接make可能不会重新编，所以最好的办法是make clean再make



## Makefile 相关知识

参考[makefile详解](https://blog.csdn.net/weixin_38391755/article/details/80380786)

makefile中，冒号前的默认为文件，冒号后为这个文件的依赖，下一行为更新这个文件需要执行的命令
如果我们只是想执行某些操作，比如clean时删除编译出来的文件，可以把这个clean前加上.PHONY : clean，表示它是个伪文件

![](/assets/images/4.PNG)

如果不加这个命令，那么如果当前路径下存在一个叫clean的文件，我们再执行make clean就会报错

常用函数：
格式：$(patsubst \<pattern\>,\<replacement\>,\<text\> )
名称：模式字符串替换函数——patsubst。
功能：查找\<text\>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式\<pattern\>，如果匹配的话，则以\<replacement\>替换。

这里，\<pattern\>可以包括通配符“%”，表示任意长度的字串。如果\<replacement\>中也包含“%”，那么，\<replacement\>中的这个“%”将是\<pattern\>中的那个“%”所代表的字串。

（可以用“\”来转义，以“%”来表示真实含义的“%”字符）
返回：函数返回被替换过后的字符串。

示例：

`$(patsubst %.c,%.o, a.c b.c)`

把字串“a.c b.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“a.o b.o”



## so嵌套引用的情况：

![](/assets/images/5.PNG)

3.so用到了2.so中的函数，2.so用到了1.so中的函数
分为两种情况：
一：2.so引用了1.h，同时在编译时也链接上了1.so的库。
这种情况，3.so再想用2.so中的函数时，直接包含2.h，然后编译时链接上2.so就可以了。因为此时2.so的符号表是完整的

二：2.so引用了1.h，但是编译时未链接1.so的库。
这种情况，在编译2.so时也是可以编译通过的，但是此时2.so中由于用到了1.so的函数，但是该函数的定义还未知，所以2.so的符号表并不完整。此时，3.so再想用2.so的函数时，只链接2.so就会报错，必须同时链接2.so和1.so，相当于把不完整的符号表补充完整。



![](/assets/images/6.PNG)

b.so 用到了c.c中的函数，但是只引用了c.h,在链接时并未链接c.a，此时b.so中的符号表是不完整的，用到的c.h中的函数只能看到一个声明，看不到具体的实现。这时a.so再链接b.so时，必须把c.c包含进去，不论是直接链接c.c对应的c.o，或者是链接打包成的c.a(可能有其他的.o被打包进来，如果只用到c.c中的文件的话，建议直接用c.o)。
总结：如果一个so的符号表不完整，可以编译过，但是该so不能再被其他程序直接引用，必须把不完整的符号表补充完整，即把缺少的符号的源文件包含进来。包含进来的方式可以直接链接目标文件.o，或链接库文件.a，.so。



makefile的**MAKEFILE_LIST**变量，是个列表变量, 在每次make读入一个makefile文件时, 都把它添加到最后一项，
可以通过

```
makefile_name := $(lastword $(MAKEFILE_LIST))
makefile_path := $(abspath $(makefile_name))
```

来获取当前的makefile的绝对路径



一个a.c或想**引用另外一个b.c中定义的函数**，有两种方式：

1.b.c在头文件b.h中声明一下这个函数，a.c只要include这个b.h就可以用到这个函数。

2.a.c直接extern声明b.c中的函数，就可以用了。

当然，这两种方式都必须能找到函数的定义，所以要不就编译时一起编进来例如，`gcc a.c b.c -o`

,或编译时a.c在编译时引用静态库b.a；要么就引用动态库。

总的来说这两种方式是一种，就是说我想用别的文件定义的函数之前，一定要声明一下这个函数（在能找到定义的情况下），不论是通过include头文件中的声明，或者是直接extern来声明。